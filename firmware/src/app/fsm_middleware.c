/******************************************************************************
Finite State Machine
Project: ../../assets/gv_fsm/_fsm_middleware.dot
Description: fsm_middleware

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.7
Generation date: 2024-09-22 19:51:29 +0200
Generated from: ../../assets/gv_fsm/_fsm_middleware.dot
The finite state machine has:
  5 states
  1 transition functions
******************************************************************************/

#include <syslog.h>
#include <stdio.h>

#include "fsm_middleware.h"

// GLOBALS
// State human-readable names
const char *state_names[] = {"init", "consume", "compute", "produce", "fatal"};


/*** USER CODE BEGIN PRIVATE ***/
static int32_t rc;
static gcode_t gcode_line;
/*** USER CODE END PRIVATE ***/

/*** USER CODE BEGIN GLOBAL ***/
bfr_gcode_t bfr_gcode_cmds;
bfr_gcode_t bfr_robot_cmds;
/*** USER CODE END GLOBAL ***/


// List of state functions
state_func_t *const state_table[NUM_STATES] = {
    do_init,    // in state init
    do_consume, // in state consume
    do_compute, // in state compute
    do_produce, // in state produce
    do_fatal,   // in state fatal
};

// Table of transition functions
transition_func_t *const transition_table[NUM_STATES][NUM_STATES] = {
    /* states:     init               , consume            , compute            , produce            , fatal               */
    /* init    */ {NULL               , NULL               , NULL               , NULL               , NULL               }, 
    /* consume */ {NULL               , NULL               , NULL               , NULL               , NULL               }, 
    /* compute */ {NULL               , NULL               , NULL               , NULL               , handle_fatal_error }, 
    /* produce */ {NULL               , NULL               , NULL               , NULL               , handle_fatal_error }, 
    /* fatal   */ {NULL               , NULL               , NULL               , NULL               , NULL               }, 
};

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: STATE_CONSUME
state_t do_init(state_data_t *data) {
    state_t next_state = STATE_CONSUME;

    syslog(LOG_INFO, "[FSM] In state init");

    /*** USER CODE BEGIN INIT ***/
    syslog(LOG_INFO, "[TG] init start");
    tg_cfg_t tg_cfg;
    RETCHECK(tg_get_dft_cfg(&tg_cfg));
    RETCHECK(tg_init(&tg_cfg));
    syslog(LOG_INFO, "[TG] init end");

    syslog(LOG_INFO, "[IG] init start");
    ig_cfg_t ig_cfg;
    RETCHECK(ig_get_dft_cfg(&ig_cfg));
    RETCHECK(ig_init(&ig_cfg));
    syslog(LOG_INFO, "[IG] init end");

    syslog(LOG_INFO, "[BFR] init start");
    bfr_init(&bfr_gcode_cmds, BFR_GCODE_CMDS_SIZE);
    syslog(LOG_INFO, "[BFR] init end");

    syslog(LOG_INFO, "[BFR] init start");
    bfr_init(&bfr_robot_cmds, BFR_ROBOT_CMDS_SIZE);
    syslog(LOG_INFO, "[BFR] init end");
    /*** USER CODE END INIT ***/

    /*** TEST BEGIN ***/
    gcode_line.cmd = G28;
    bfr_produce(&bfr_gcode_cmds, gcode_line);

    gcode_line.cmd = M04;
    bfr_produce(&bfr_gcode_cmds, gcode_line);

    gcode_line.cmd = M05;
    bfr_produce(&bfr_gcode_cmds, gcode_line);

    gcode_line.cmd = G01;
    gcode_line.data.x = 0;
    gcode_line.data.y = 0;
    gcode_line.data.z = -180;
    gcode_line.data.k = 0;
    gcode_line.data.t = 0;
    bfr_produce(&bfr_gcode_cmds, gcode_line);
    /*** TEST END ***/

    switch (next_state) {
    case STATE_CONSUME:
        break;
    default:
        syslog(LOG_WARNING, "[FSM] Cannot pass from init to %s, remaining in this state", state_names[next_state]);
        next_state = NO_CHANGE;
    }

    return next_state;
}


// Function to be executed in state consume
// valid return states: NO_CHANGE, STATE_CONSUME, STATE_COMPUTE, STATE_PRODUCE
state_t do_consume(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    syslog(LOG_INFO, "[FSM] In state consume");

    /*** USER CODE BEGIN CONSUME ***/
    // get item from buffer
    BFRCHECK(bfr_consume(&bfr_gcode_cmds, &gcode_line));

    // handle new item
    switch (gcode_line.cmd)
    {
    case G01:
    case G02:
    case G03:
        RETCHECK(tg_set_next_trajectory(gcode_line));
        next_state = STATE_COMPUTE;
        break;

    case G90:
    case G91:
        RETCHECK(tg_set_positioning(gcode_line.cmd));
        next_state = NO_CHANGE;
        break;

    case G28:
        RETCHECK(tg_set_home());
        next_state = STATE_PRODUCE;
        break;

    case G04:
    case M04:
    case M05:
    case M17:
    case M18:
        next_state = STATE_PRODUCE;
        break;

    default:
        break;
    }
    /*** USER CODE END CONSUME ***/  

    switch (next_state) {
    case NO_CHANGE:
    case STATE_CONSUME:
    case STATE_COMPUTE:
    case STATE_PRODUCE:
        break;
    default:
        syslog(LOG_WARNING, "[FSM] Cannot pass from consume to %s, remaining in this state", state_names[next_state]);
        next_state = NO_CHANGE;
    }

    return next_state;
}


// Function to be executed in state compute
// valid return states: STATE_PRODUCE, STATE_FATAL
state_t do_compute(state_data_t *data) {
    state_t next_state = STATE_PRODUCE;

    syslog(LOG_INFO, "[FSM] In state compute");

    /*** USER CODE BEGIN COMPUTE ***/
    RETCHECK(tg_get_via_point(&gcode_line));
    RETCHECK(ig_get_inverse_geometry(&gcode_line));
    /*** USER CODE END COMPUTE ***/

    switch (next_state) {
    case STATE_CONSUME:
    case STATE_PRODUCE:
    case STATE_FATAL:
        break;
    default:
        syslog(LOG_WARNING, "[FSM] Cannot pass from compute to %s, remaining in this state", state_names[next_state]);
        next_state = NO_CHANGE;
    }

    return next_state;
}


// Function to be executed in state produce
// valid return states: NO_CHANGE, STATE_CONSUME, STATE_COMPUTE, STATE_PRODUCE
state_t do_produce(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    syslog(LOG_INFO, "[FSM] In state produce");

    /*** USER CODE BEGIN PRODUCE ***/
    BFRCHECK(bfr_produce(&bfr_robot_cmds, gcode_line));

    syslog(LOG_INFO, "[PRODUCED] cmd: %d\tx: %f y: %f z: %f t: %f", 
        gcode_line.cmd, gcode_line.data.x, gcode_line.data.y, 
        gcode_line.data.z, gcode_line.data.t);

    // handle item
    switch (gcode_line.cmd)
    {
    case G01:
    case G02:
    case G03:
        next_state = STATE_COMPUTE;
        break;

    case G04:
    case G28:
    case M04:
    case M05:
    case M17:
    case M18:
        next_state = STATE_CONSUME;
        break;

    default:
        break;
    }

    /*** USER CODE END PRODUCE ***/

    switch (next_state) {
    case NO_CHANGE:
    case STATE_CONSUME:
    case STATE_COMPUTE:
    case STATE_PRODUCE:
        break;
    default:
        syslog(LOG_WARNING, "[FSM] Cannot pass from produce to %s, remaining in this state", state_names[next_state]);
        next_state = NO_CHANGE;
    }

    return next_state;
}


// Function to be executed in state fatal
// valid return states: NO_CHANGE
state_t do_fatal(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    syslog(LOG_INFO, "[FSM] In state fatal");

    /*** USER CODE BEGIN FATAL ***/
    switch (rc)
    {
    case MP_END_OF_TRAJECTORY:
        syslog(LOG_INFO, "MP_END_OF_TRAJECTORY");
        next_state = STATE_CONSUME;
        break;
    case MOD_ERR_BAD_ARGUMENT:
        syslog(LOG_ERR, "MOD_ERR_BAD_ARGUMENT");
        break;
    case MP_ERR_NOT_CALIBRATED:
        syslog(LOG_ERR, "MP_ERR_NOT_CALIBRATED");
        break;
    case MP_ERR_BAD_TRAVEL_TIME:
        syslog(LOG_ERR, "MP_ERR_BAD_TRAVEL_TIME");
        break;
    case MP_ERR_WS_LIMIT:
        syslog(LOG_ERR, "MP_ERR_WS_LIMIT");
        break;
    case MP_ERR_JOINT_LIMIT:
        syslog(LOG_ERR, "MP_ERR_JOINT_LIMIT");
        break;

    default:
        syslog(LOG_ERR, "UNDEFINED ERROR");
        break;
    }
    
    /*** USER CODE END FATAL ***/

    switch (next_state) {
    case NO_CHANGE:
    case STATE_CONSUME:
        break;
    default:
        syslog(LOG_WARNING, "[FSM] Cannot pass from fatal to %s, remaining in this state", state_names[next_state]);
        next_state = NO_CHANGE;
    }

    return next_state;
}


/*  _____                    _ _   _              
* |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
*   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
*   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
*   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
*                                                
*   __                  _   _                 
*  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
* | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
* |  _| |_| | | | | (__| |_| | (_) | | | \__ \
* |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
*/

// This function is called in 2 transition:
// 1. from compute to fatal
// 2. from produce to fatal
void handle_fatal_error(state_data_t *data) {
    syslog(LOG_INFO, "[FSM] State transition handle_fatal_error");

    /*** USER CODE BEGIN HANDLE_FATAL_ERROR ***/

    /*** USER CODE END HANDLE_FATAL_ERROR ***/

    return;
}



/*  ____  _        _        
* / ___|| |_ __ _| |_ ___  
* \___ \| __/ _` | __/ _ \
*  ___) | || (_| | ||  __/ 
* |____/ \__\__,_|\__\___| 
*                          
*                                              
*  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
* | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
* | | | | | | (_| | | | | (_| | (_| |  __/ |   
* |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
*                              |___/           
*/

state_t run_middleware(state_t cur_state, state_data_t *data) {
    state_t new_state = state_table[cur_state](data);
    if (new_state == NO_CHANGE) {
        new_state = cur_state;
    }

    transition_func_t *transition = transition_table[cur_state][new_state];
    if (transition) {
        transition(data);
    }

    return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
    state_t cur_state = STATE_INIT;
    openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
    syslog(LOG_INFO, "Starting SM");
    do {
        cur_state = run_state(cur_state, NULL);
        sleep(1);
    } while (cur_state != STATE_FATAL);
    run_state(cur_state, NULL);
    return 0;
}
#endif
